<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
   <HEAD>
      <TITLE>My first HTML document</TITLE>
      <style rel="stylesheet" type="text/css">
body {
 font-size: 23px;
 
 margin-top: 50px;
    margin-bottom: 50px;
    margin-right: 80px;
    margin-left: 80px;
    
    padding-top: 50px;
    padding-bottom: 50px;
    padding-right: 80px;
    padding-left: 80px;
    
    line-height:35px;
}
img {
 width:900px;
}
</style>
      <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    "HTML-CSS" : {
        availableFonts : ["STIX"],
        preferredFont : "STIX",
        webFont : "STIX-Web",
        imageFont : null
    }
});
</script>
     <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js" type="text/javascript">    
    MathJax.Hub.Config({
        HTML: ["input/TeX","output/HTML-CSS"],
        TeX: { extensions: ["AMSmath.js","AMSsymbols.js"], 
               equationNumbers: { autoNumber: "AMS" } },
        extensions: ["tex2jax.js"],
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: { inlineMath: [ ['$$$','$$$'] ],
                   displayMath: [ ['$$$$','$$$$'] ],
                   processEscapes: true },
        "HTML-CSS": { availableFonts: ["TeX"],
                      linebreaks: { automatic: true } }
    });
</script>
   </HEAD>
   <BODY>
<xmp>

Make is an useful program which can be used 
for compiling tons of source files from huge project

And you can have cases where you differenty compile the same source file
whose case can be helped by Make

You also have case where you should read some system configurations from system,
then you need to compile files based on those system configurations,
then you need to move compiled binary files into system directory

This compilicated steps of compile can be helped by Make

======================================================================
- Makefile is the core file in Make program

- Makefile contains rules of compile and build
Rules are composed of compile commands and shell commands

- Makefile describes dependencies against each target file
which means Make program automatically detects 
those dependencies against target file
so that Make can perform a compilation procedure more effectively.

For example, 
- case where there is modifications 
on one source file from tons of source files
- case where you need to link many files but when one file is missing

In this cases, you don't need to compile whole project
but you can compile the project partially 
by detecting above dependencies to each file

- Makefile also can do other tasks as well as compiling source files
Makefile can be used in a similar way of using a shell script file.

======================================================================
How to use Make

# You create "makefile" or "Makefile" in current directory, and run
make

# You perform Make program based on rules written in Makefile
If you don't specify targets, make builds against "all" targets
make [-f makefile] [options] [targets]

======================================================================
Makefile is composed of

- Target: You heard that Makefile is scripts written in shell commands
But to represent dependencies in Makefile 
rather than from general shell script file,
you need to make groups on shell commands as targets

So, you can say many targets are arranged in Makefile
And when dependency is satisfied against each target, 
shell commands in that target are executed

A list of dependencies is list of file names
which means you create "target" by using specified source files

It means if you have those files, "target" is excuted

If you don't have files which are used as dependencies,
you perform compile to create non-existing dependency-files

To compile above missing files, 
missing files are also considered as "target"
If that "target" is not specified, you will get Make error

You can speficy "target" which you want to execute
make [-f makefile] [options] [targets]

======================================================================
You can use variables in Makefile

Variable in Makefile is called macro

How to define macro: macro_name=value

How to use macro: $(macro_name) or ${macro_name}

======================================================================
Let's see "target" in more detail

- You build "target" by executing specified commands for "target"

- If you don't have specified files which are designated in the dependencies,
you perform corresponding build

- When a list of dependency files is updated,
you reperform building "target"

- all: you can specify the target called "all"

- clean: you remove all files which are generated by Make

- Each command line should start with "tab"

======================================================================
Basic macro
- CC: specifies compiler programs
- CFLAGS: specifies compile options

======================================================================
Example of Makefile

# Makefile for creating hello file, to create Makefile, run
touch Makefile

Write following contents into Makefile file

# you specify gcc compiler on CC macro
CC=gcc

# You speficy compile options on CFLAGS macro
CFLAGS=-g -W -Wall -c

# You configure all as target 
# hello file is dependency file for achieving "all" target
# all target has no tasks
# "all" target only checks whether dependency (hello) is satisfied or not
# If hello file is missing in our project directories, 
# Make program will go to "hello" target to create hello file
all:hello

# You configure hello target
# dependencies for hello target are main.o factorial.o hello.o
# If you have main.o factorial.o hello.o files
# you will run following compile command to create hello file
hello:main.o factorial.o hello.o
  # If you don't have above specified files as dependency for hello target
  # this is not excuted
  # Then, Make program tries to create missing files
  # So, Make program tries to find target related to missing file
  # So, Make program goes to that target
  $(CC) -o hello main.o factorial.o hello.o

main.o:main.c functions.h
  # You use compile options by using CFLAGS macro
  $(CC) $(CFLAGS) main.o

factorial.o:factorial.c functions.h
  $(CC) $(CFLAGS) factorial.c

hello.o:hello.c
  $(CC) $(CFLAGS) hello.c

clean:
  rm -rf *.o hello

</xmp>
   </BODY>
</HTML>


