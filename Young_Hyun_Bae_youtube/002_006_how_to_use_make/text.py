Make is an useful program which can be used for compiling tons of source files from huge project

And you can have cases where you differenty compile the same source file
whose case can be helped by Make

You also have case where you should read some system configurations from system,
then you need to compile files based on those configurations,
then you need to move compiled binary files into system directory
This compilicated steps of compile can be helped by Make

# ======================================================================
- Makefile is the core file in Make program

- Makefile contains rules of compile and build
Rules are composed of compile commands and shell commands

- Makefile describes dependencies to each source file
which means Make program automatically detects those dependencies
so that Make performs compile procedure more effectively.

For example, case where there is modifications on one source file from tons of source files
case where you need to link many files but when one file is missing

In this cases, you don't need to compile whole process
but you can compile partially by detecting above dependencies to each file

- Makefile also can do other tasks as well as compiling source files
Makefile can be used in a similar way to using shell script.

# ======================================================================
How to use Make

# You use "makefile" or "Makefile" resided in current directory 
make

# You perform make based on rules written in makefile
If you don't specify targets, make builds against "all" targets
make [-f makefile] [options] [targets]

# ======================================================================
Makefile is composed of

- Target: You heard that Makefile is scripts written by shell commands
But to represent dependencies in Makefile rather than general shell script file,
you make grouping on shell commands as targets
So, you can say many targets are arranged in Makefile
And when dependency is satisfied against each target, 
shell commands in that target are executed

A list of dependencies is list of file names
which means you create "target" by using specified files

It means if you have those files, "target" is excuted

If you don't have file against dependency,
you perform compile to create non-existing files

To compile above missing files, you also have "target"
If that "target" is not specified, you will get make error

You can speficy "target" which you want to execute
make [-f makefile] [options] [targets]

# ======================================================================
You can use variable in makefile

variable in makefile is called macro

How to define macro: macro_name=value

How to use macro: $(macro_name) or ${macro_name}

# ======================================================================
Let's see "target" in more detail

- You build "target" by executing specified commands for "target"

- If you don't have specified files which are designated in the dependencies,
you perform corresponding build

- When a list of dependency files is updated,
you reperform building "target"

- all: you specify "all build targets" into the list of dependency

- clean: you remove all files which are generated by Make

- Each command line should start with "tab"

# ======================================================================
Basic macro
- CC: specifies compiler program
- CFLAGS: specifies compile option

# ======================================================================
Example of Makefile

# makefile for hello

# you specify gcc compiler on CC macro
CC=gcc

# You speficy compile options on CFLAGS macro
CFLAGS=-g -W -Wall -c

# You configure all as target 
# hello is dependency for all target
# all target has no tasks
# At this only checks whether dependency (hello) is satisfied or not
# If hello is missing, make go to hello target
all:hello

# You configure hello target
# dependency of hello target is main.o factorial.o hello.o
# If you have main.o factorial.o hello.o files
hello:main.o factorial.o hello.o
  # You run compile to create hello file
  # If you don't have above specified files as dependency for hello target
  # this is not excuted
  # Then, make tries to create missing file
  # So, make tries to find target related to missing file
  # So, make file goes to that target
  $(CC) -o hello main.o factorial.o hello.o

main.o:main.c functions.h
  # You use compile options by using CFLAGS macro
  $(CC) $(CFLAGS) main.o

factorial.o:factorial.c functions.h
  $(CC) $(CFLAGS) factorial.c

hello.o:hello.c
  $(CC) $(CFLAGS) hello.c

clean:
  rm -rf *.o hello




